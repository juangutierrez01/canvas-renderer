<!DOCTYPE html>
<html>
  <head>
    <title>renderer</title>
  </head>
  <body style="margin:0;overflow:hidden">
    <canvas style="display:block"></canvas>
    <script>
/****************************************************************************/
const canvas = document.querySelector("canvas");
const context = canvas.getContext("2d");

const V = {
  magnitude: function(v) {
    return Math.hypot(v[0], v[1], v[2]);
  },

  nonZeroMagnitude: function(v) {
    return Math.hypot(v[0], v[1], v[2]) || 1;
  },

  dot: function(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
  },

  cos: function(v1, v2) {
    return this.dot(v1, v2) / (this.nonZeroMagnitude(v1) * this.nonZeroMagnitude(v2));
  },

  angle: function(v1, v2) {
    return Math.acos(this.cos(v1, v2));
  },

  // The signed magnitude of the projection of v1 onto v2
  scalarProjection: function(v1, v2) {
    return this.dot(v1, v2) / this.nonZeroMagnitude(v2);
  },

  sum: function(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
  },

  // The sum of v1 and the opposite of v2 (v1-v2)
  difference: function(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
  },

  scaled: function(v, s) {
    return [s*v[0], s*v[1], s*v[2]];
  },

  // The cross product of v1 and v2 (v1×V2)
  cross: function(v1, v2) {
    return [
      v1[1]*v2[2] - v1[2]*v2[1],
      v1[2]*v2[0] - v1[0]*v2[2],
      v1[0]*v2[1] - v1[1]*v2[0]
    ];
  },

  // Unit normal vector attained from v1×v2 
  normal: function(v1, v2) {
    return this.unit(this.cross(v1, v2));
  },

  // Rotation of vector v1 about unit plane v2 by amount s
  rotation: function(v1, v2, s) {
    s %= Math.PI;

    const projection = this.projection(v1, v2);
    v1 = this.difference(v1, projection);

    if (s < 0) {
      v1 = this.scaled(v1, -1);
      s += Math.PI;
    }

    if (s === Math.PI/2) {
      return this.sum(this.cross(v1, v2), projection);
    }

    const normal = this.scaled(this.cross(v1, v2), Math.tan(s));
    const sum = this.sum(v1, normal);
    v1 = this.scaled(sum, Math.cos(s));
    return this.sum(v1, projection);
  },

  unit: function(v) {
    return this.scaled(v, 1 / this.nonZeroMagnitude(v));
  },

  // Projection of v1 onto v2
  projection: function(v1, v2) {
    return this.scaled(v2, this.dot(v1, v2) / Math.pow(this.nonZeroMagnitude(v2), 2));
  },

  // Projection of vector v1 onto plane v2
  planarProjection: function(v1, v2) {
    return this.difference(v1, this.projection(v1, v2));
  },
}

const points = [
  [0, 0, 0],
  [0, 0, 4],
  [-1, -1, -1],
  [-1, 1, -1],
  [1, 1, -1],
  [1, -1, -1],
  [-1, -1, 1],
  [-1, 1, 1],
  [1, 1, 1],
  [1, -1, 1],
  [3, -1, -1],
  [3, 1, -1],
  [5, 1, -1],
  [5, -1, -1],
  [3, -1, 1],
  [3, 1, 1],
  [5, 1, 1],
  [5, -1, 1],
  [-5, -1, -1],
  [-5, 1, -1],
  [-3, 1, -1],
  [-3, -1, -1],
  [-5, -1, 1],
  [-5, 1, 1],
  [-3, 1, 1],
  [-3, -1, 1]
];

const camera = {
  position: [0, -5, 0],
  direction: [0, 1, 0],
  up: [0, 0, 1],
  right: [1, 0, 0],
  GLOBAL_UP: [0, 0, 1],
  fieldOfView: 110 * Math.PI / 180,
  linearPerspective: function(point) {
    point = V.difference(point, this.position);

    if (V.dot(point, this.direction) <= 0) {
      return [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY];
    }

    point = V.scaled(point, 1 / V.dot(point, this.direction));
    const fovScale = Math.tan(this.fieldOfView / 2);
    const x = V.scalarProjection(point, this.right) / fovScale;
    const y = V.scalarProjection(point, this.up) / fovScale;

    return [x, y];
  },
  sphericalPerspective: function(point) {
    point = V.difference(point, this.position);

    const visualAngle = V.angle(this.direction, point) * 2;
    const screenRadius = (visualAngle / this.fieldOfView);

    const projection = V.planarProjection(point, this.direction);

    const x = screenRadius * V.cos(projection, this.right);
    const y = screenRadius * V.cos(projection, this.up);

    return [x, y];
  },
  screenPosition: function(point) {
    return this.linearPerspective(point);
  },
  rotateHorizontally: function(angle) {
    this.direction = V.unit(V.rotation(this.direction, this.GLOBAL_UP, angle));
    this.up = V.unit(V.rotation(this.up, this.GLOBAL_UP, angle));
    this.right = V.normal(this.direction, this.up);
  },
  rotateVertically: function(angle) {
    this.direction = V.unit(V.rotation(this.direction, this.right, angle));
    this.up = V.unit(V.rotation(this.up, this.right, angle));
  }
};

window.addEventListener("resize", (function resizeCanvas() {
    canvas.width = document.documentElement.clientWidth;
    canvas.height = document.documentElement.clientHeight;
    return resizeCanvas;
})());

const keyMap = new Map([
  ["KeyW", 0],
  ["KeyA", 0],
  ["KeyS", 0],
  ["KeyD", 0],
  ["Space", 0],
  ["Shift", 0],
  ["ArrowLeft", 0],
  ["ArrowRight", 0],
  ["ArrowUp", 0],
  ["ArrowDown", 0]
]);

window.addEventListener("keydown", (event) => {
  if (keyMap.has(event.code)) {
    keyMap.set(event.code, 1);
  }
  
  keyMap.set("Shift", event.shiftKey ? 1 : 0);
});

window.addEventListener("keyup", (event) => {
  if (keyMap.has(event.code)) {
    keyMap.set(event.code, 0);
  }

  keyMap.set("Shift", event.shiftKey ? 1 : 0);
});

window.addEventListener("blur", (event) => {
  keyMap.forEach((value, key, map) => {
    map.set(key, 0);
  });
});

let previousTime = document.timeline.currentTime;
let elapsedTime = 0;

window.requestAnimationFrame(function draw(currentTime) {
  window.requestAnimationFrame(draw);
  elapsedTime = currentTime - previousTime;
  previousTime = currentTime;

  const canvasRadius = Math.max(canvas.width, canvas.height) / 2;
  const movementSpeed = 0.03;
  const rotationSpeed = Math.PI/180;
  camera.position = V.sum(camera.position, V.scaled(camera.direction, (keyMap.get("KeyW") - keyMap.get("KeyS")) * movementSpeed));
  camera.position = V.sum(camera.position, V.scaled(camera.right, (keyMap.get("KeyD") - keyMap.get("KeyA")) * movementSpeed));
  camera.position = V.sum(camera.position, V.scaled(camera.GLOBAL_UP, (keyMap.get("Space") * (-2*keyMap.get("Shift") + 1)) * movementSpeed));
  camera.rotateHorizontally((keyMap.get("ArrowRight") - keyMap.get("ArrowLeft")) * rotationSpeed);
  camera.rotateVertically((keyMap.get("ArrowDown") - keyMap.get("ArrowUp")) * rotationSpeed);

  context.fillStyle = "cornflowerblue";
  context.fillRect(0, 0, canvas.width, canvas.height);

  context.fillStyle = "oldlace";
  for (const point of points) {
    const [x, y] = camera.screenPosition(point);
    context.fillRect(
      (canvas.width / 2) + canvasRadius*x - 5,
      (canvas.height / 2) - canvasRadius*y - 5,
      10,
      10
    );
  }
});
/****************************************************************************/
    </script>
  </body>
</html>

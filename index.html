<!DOCTYPE html>
<html>
  <head>
    <title>renderer</title>
  </head>
  <body style="margin:0;overflow:hidden">
    <canvas style="display:block"></canvas>
    <script>
/****************************************************************************/
const canvas = document.querySelector("canvas");
const context = canvas.getContext("2d");

const V = {
  magnitude: function(v) {
    return Math.hypot(v[0], v[1], v[2]);
  },

  dot: function(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
  },

  cos: function(v1, v2) {
    return this.dot(v1, v2) / (this.magnitude(v1) * this.magnitude(v2));
  },

  angle: function(v1, v2) {
    return Math.acos(this.cos(v1, v2));
  },

  scalarProjection: function(v1, v2) {
    return this.dot(v1, v2) / this.magnitude(v2);
  },

  sum: function(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
  },

  difference: function(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
  },

  scaled: function(v, s) {
    return [s*v[0], s*v[1], s*v[2]];
  },

  cross: function(v1, v2) {
    return [
      v1[1]*v2[2] - v1[2]*v2[1],
      v1[2]*v2[0] - v1[0]*v2[2],
      v1[0]*v2[1] - v1[1]*v2[0]
    ];
  },

  normal: function(v1, v2) {
    return this.unit(this.cross(v1, v2));
  },

  // 0 <= s < PI/2
  rotation: function(v1, v2, s) {
    const normal = this.scaled(this.normal(v1, v2), Math.tan(s));
    const sum = this.sum(v1, normal);

    return this.scaled(sum, this.magnitude(v1) * Math.cos(s));
  },

  unit: function(v) {
    return this.scaled(v, 1 / this.magnitude(v));
  },

  projection: function(v1, v2) {
    return this.scaled(v2, this.dot(v1, v2) / Math.pow(this.magnitude(v2), 2));
  }
}

console.log(V.rotation([1, 0, 0], [0, 1, 0], Math.PI/4));

const points = [
  [0, 0, 0],
  [-1, -1, -1],
  [-1, 1, -1],
  [1, 1, -1],
  [1, -1, -1],
  [-1, -1, 1],
  [-1, 1, 1],
  [1, 1, 1],
  [1, -1, 1],
  [3, -1, -1],
  [3, 1, -1],
  [5, 1, -1],
  [5, -1, -1],
  [3, -1, 1],
  [3, 1, 1],
  [5, 1, 1],
  [5, -1, 1],
  [-5, -1, -1],
  [-5, 1, -1],
  [-3, 1, -1],
  [-3, -1, -1],
  [-5, -1, 1],
  [-5, 1, 1],
  [-3, 1, 1],
  [-3, -1, 1]
];

const camera = {
  position: [0, -5, 0],
  direction: [0, 1, 0],
  up: [0, 0, 1],
  right: [1, 0, 0],
  fieldOfView: 110 * Math.PI / 180,
  linearPerspective: function(point) {
    point = V.difference(point, this.position);

    if (V.scalarProjection(point, this.direction) <= 0) {
      return [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY];
    }

    point = V.scaled(point, 1 / V.dot(point, this.direction));
    const fovScale = Math.tan(this.fieldOfView / 2);
    const x = V.scalarProjection(point, this.right) / fovScale;
    const y = V.scalarProjection(point, this.up) / fovScale;

    return [x, y];
  },
  sphericalPerspective: function(point) {
    point = V.difference(point, this.position);

    const visualAngle = V.angle(this.direction, point) * 2;
    const screenRadius = (visualAngle / this.fieldOfView);

    const projection = V.difference(point, V.projection(point, this.direction));

    const x = screenRadius * V.cos(projection, this.right);
    const y = screenRadius * V.cos(projection, this.up);

    return [x, y];
  },
  screenPosition: function(point) {
    return this.linearPerspective(point);
  }
};

window.addEventListener("resize", (function resizeCanvas() {
    canvas.width = document.documentElement.clientWidth;
    canvas.height = document.documentElement.clientHeight;
    return resizeCanvas;
})());

let leftPressed = 0;
let rightPressed = 0;
let upPressed = 0;
let downPressed = 0;

window.addEventListener("keydown", (event) => {
  switch (event.code) {
    case "KeyW":
      upPressed = 1;
      break;
    case "KeyA":
      leftPressed = 1;
      break;
    case "KeyS":
      downPressed = 1;
      break;
    case "KeyD":
      rightPressed = 1;
      break;
    default:
      break;
  }
});

window.addEventListener("keyup", (event) => {
  switch (event.code) {
    case "KeyW":
      upPressed = 0;
      break;
    case "KeyA":
      leftPressed = 0;
      break;
    case "KeyS":
      downPressed = 0;
      break;
    case "KeyD":
      rightPressed = 0;
      break;
    default:
      break;
  }
});

window.addEventListener("blur", (event) => {
  upPressed = 0;
  leftPressed = 0;
  downPressed = 0;
  rightPressed = 0;
});

window.requestAnimationFrame(function draw() {
  window.requestAnimationFrame(draw);
  const canvasRadius = Math.max(canvas.width, canvas.height) / 2;
  const speed = 0.02;
  camera.position[0] += (rightPressed - leftPressed) * speed;
  camera.position[1] += (upPressed - downPressed) * speed;
  
  context.fillStyle = "cornflowerblue";
  context.fillRect(0, 0, canvas.width, canvas.height);

  context.fillStyle = "oldlace";
  for (const point of points) {
    const [x, y] = camera.screenPosition(point);
    context.fillRect(
      (canvas.width / 2) + canvasRadius*x - 5,
      (canvas.height / 2) + canvasRadius*y - 5,
      10,
      10
    );
  }
});
/****************************************************************************/
    </script>
  </body>
</html>
